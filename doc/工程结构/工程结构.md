æˆ‘å…ˆåœ¨æœ‰ä¸¤ä¸ªpyæ–‡ä»¶éœ€è¦åŒæ—¶è¿è¡Œzebra_crossing_detection.pyå’Œred_light_detection.pyï¼Œåº”è¯¥æ€ä¹ˆåšï¼Ÿ
éœ€è¦è®©ä¸¤ä¸ªæ–‡ä»¶åŒæ—¶è¿è¡Œåœ¨ä¸€ä¸ªæ‘„åƒå¤´ä¸Šï¼Œå¯èƒ½éœ€è¦ä¿®æ”¹ä¸¤ä¸ªæ–‡ä»¶å·²è®©è¿›ç¨‹åŒæ—¶è¿è¡Œ

å·¥ç¨‹ç»“æ„ï¼š
ğŸ“¦zebra_crossing_detection
 â”£ ğŸ“‚traffic_detection
 â”ƒ â”— ğŸ“œred_light_detection.py
 â”£ ğŸ“‚zebra_detection
 â”ƒ â”— ğŸ“œzebra_crossing_detection.py
 â”— main.py
 â”— ğŸ“œ.gitignore


## ä»£ç ï¼š

### 1 zebra_crossing_detection.pyï¼š

```python
import cv2
import numpy as np

def ensure_odd(val):
    return val if val % 2 == 1 else val + 1

def zebra_crossing_detection():
    cap = cv2.VideoCapture(0)  # ä½¿ç”¨æ‘„åƒå¤´
    if not cap.isOpened():
        print("Error: Unable to open camera.")
        return
    
    # è®¾ç½®é»˜è®¤å‚æ•°å€¼
    crop_percent = 0.3
    median_blur_val = 15
    gaussian_blur_val = 15
    canny_threshold1 = 50
    canny_threshold2 = 134
    morph_kernel_size = 5
    area_threshold = 3000
    hough_threshold = 16
    line_threshold = 10

    while True:
        ret, frame = cap.read()  # ä»æ‘„åƒå¤´è¯»å–å¸§
        if not ret:
            print("Error: Unable to capture frame.")
            break

        # å¤„ç†å›¾åƒ
        height = frame.shape[0]
        cropped_image = frame[int(crop_percent * height):, :]
        
        gray = cv2.cvtColor(cropped_image, cv2.COLOR_BGR2GRAY)
        
        # åº”ç”¨ä¸­å€¼æ»¤æ³¢
        if median_blur_val > 1:
            blurred = cv2.medianBlur(gray, median_blur_val)
        else:
            blurred = gray
        
        # åº”ç”¨é«˜æ–¯æ¨¡ç³Š
        if gaussian_blur_val > 1:
            gaussian_blurred = cv2.GaussianBlur(blurred, (gaussian_blur_val, gaussian_blur_val), 0)
        else:
            gaussian_blurred = blurred
        
        edges = cv2.Canny(gaussian_blurred, canny_threshold1, canny_threshold2)
        
        kernel = np.ones((morph_kernel_size, morph_kernel_size), np.uint8)
        closed_edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)
        
        contours, _ = cv2.findContours(closed_edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        mask = np.zeros_like(closed_edges)
        for contour in contours:
            if cv2.contourArea(contour) > area_threshold:
                cv2.drawContours(mask, [contour], -1, (255), thickness=cv2.FILLED)
        
        roi = cv2.bitwise_and(cropped_image, cropped_image, mask=mask)
        
        roi_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        roi_edges = cv2.Canny(roi_gray, canny_threshold1, canny_threshold2)
        
        lines = cv2.HoughLinesP(roi_edges, 1, np.pi / 180, threshold=hough_threshold, minLineLength=50, maxLineGap=10)
        
        line_image = np.copy(cropped_image)
        if lines is not None:
            for line in lines:
                for x1, y1, x2, y2 in line:
                    cv2.line(line_image, (x1, y1), (x2, y2), (0, 255, 0), 2)
        
        detected = lines is not None and len(lines) > line_threshold

        cv2.imshow('Detected Lines', line_image)
        
        if cv2.waitKey(1) & 0xFF == 27:  # æŒ‰ä¸‹ 'Esc' é”®é€€å‡º
            break

    cap.release()
    cv2.destroyAllWindows()
    return detected

# è°ƒç”¨å‡½æ•°è¿›è¡Œæµ‹è¯•
detected = zebra_crossing_detection()
print("Zebra Crossing Detected: ", detected)

```

### 2 red_light_detection.pyï¼š

```python
import cv2
import numpy as np

def ensure_odd(val):
    return val if val % 2 == 1 else val + 1

def red_light_detection():
    # æ‰“å¼€æ‘„åƒå¤´
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("Cannot open camera")
        return

    # è®¾ç½®é»˜è®¤å‚æ•°å€¼
    smooth_kernel_size = 21
    gaussian_blur_val = 15
    lower_hue = 0
    upper_hue = 10
    lower_saturation = 100
    upper_saturation = 255
    lower_value = 100
    upper_value = 255
    morph_kernel_size = 5
    min_area = 400
    max_area = 3000

    while True:
        # ä»æ‘„åƒå¤´æ•è·ä¸€å¸§
        ret, original_image = cap.read()
        if not ret:
            print("Failed to grab frame")
            break

        # å¹³æ»‘æ»¤æ³¢
        smooth = cv2.medianBlur(original_image, smooth_kernel_size)
        
        # é«˜æ–¯æ¨¡ç³Š
        gaussian_blurred = cv2.GaussianBlur(smooth, (gaussian_blur_val, gaussian_blur_val), 0)
        
        # è½¬æ¢åˆ° HSV è‰²å½©ç©ºé—´
        hsv = cv2.cvtColor(gaussian_blurred, cv2.COLOR_BGR2HSV)
        
        # æå–çº¢è‰²åŒºåŸŸ
        lower_red = np.array([lower_hue, lower_saturation, lower_value])
        upper_red = np.array([upper_hue, upper_saturation, upper_value])
        mask = cv2.inRange(hsv, lower_red, upper_red)
        
        # å½¢æ€å­¦æ“ä½œï¼Œä¾µèš€å’Œè†¨èƒ€è®©çº¢ç¯è½®å»“é—­åˆ
        kernel = np.ones((morph_kernel_size, morph_kernel_size), np.uint8)
        morph = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
        
        # æŸ¥æ‰¾è½®å»“
        contours, _ = cv2.findContours(morph, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        detected = False
        output_image = original_image.copy()
        for contour in contours:
            area = cv2.contourArea(contour)
            if min_area < area < max_area:
                (x, y), radius = cv2.minEnclosingCircle(contour)
                center = (int(x), int(y))
                radius = int(radius)
                circle_area = np.pi * (radius ** 2)
                
                if min_area < circle_area < max_area:
                    cv2.circle(output_image, center, radius, (0, 255, 0), 2)
                    detected = True
        
        cv2.imshow('Red Light Detection', output_image)
        
        if cv2.waitKey(1) & 0xFF == 27:  # æŒ‰ä¸‹ 'Esc' é”®é€€å‡º
            break

    cap.release()
    cv2.destroyAllWindows()
    return detected

# è°ƒç”¨å‡½æ•°è¿›è¡Œæµ‹è¯•
detected = red_light_detection()
print("Red Light Detected: ", detected)


```

ğŸ“¦zebra_redlight_detection
 â”£ ğŸ“‚.git
 â”£ ğŸ“‚image
 â”ƒ â”£ ğŸ“œ1.json
 â”ƒ â”£ ğŸ“œ1.png
 â”ƒ â”£ ğŸ“œ1_gray.png
 â”ƒ â”£ ğŸ“œ2.json
 â”ƒ â”£ ğŸ“œ2.png
 â”ƒ â”£ ğŸ“œ3.json
 â”ƒ â”£ ğŸ“œ3.png
 â”ƒ â”£ ğŸ“œfe9ee2fae4d6cc95f3bce01334d1016.jpg
 â”ƒ â”£ ğŸ“œRED_LIGHT.json
 â”ƒ â”— ğŸ“œRED_LIGHT.png
 â”£ ğŸ“‚linux
 â”ƒ â”£ ğŸ“œcamera_list.py
 â”ƒ â”£ ğŸ“œcamera_test.py
 â”ƒ â”— ğŸ“œmain.py
 â”£ ğŸ“‚Parameter_adjustment_assistant
 â”ƒ â”£ ğŸ“‚traffic_detection
 â”ƒ â”ƒ â”£ ğŸ“œredlight_debug.py
 â”ƒ â”ƒ â”— ğŸ“œred_live_debug.py
 â”ƒ â”— ğŸ“‚zebra_detection
 â”ƒ â”ƒ â”£ ğŸ“œzebra_debug.py
 â”ƒ â”ƒ â”— ğŸ“œzebra_live_debug.py
 â”£ ğŸ“‚test
 â”ƒ â”£ ğŸ“œcamera_test.py
 â”ƒ â”£ ğŸ“œcanny_debug.py
 â”ƒ â”£ ğŸ“œGrayscale_threshold_debug.py
 â”ƒ â”£ ğŸ“œHSV_debug.py
 â”ƒ â”£ ğŸ“œred_light_detection.py
 â”ƒ â”— ğŸ“œzebra_crossing_detection.py
 â”£ ğŸ“‚traffic_detection
 â”ƒ â”£ ğŸ“‚__pycache__
 â”ƒ â”ƒ â”— ğŸ“œred_light_detection.cpython-38.pyc
 â”ƒ â”— ğŸ“œred_light_detection.py
 â”£ ğŸ“‚zebra_detection
 â”ƒ â”£ ğŸ“‚__pycache__
 â”ƒ â”ƒ â”— ğŸ“œzebra_crossing_detection.cpython-38.pyc
 â”ƒ â”— ğŸ“œzebra_crossing_detection.py
 â”£ ğŸ“œ.gitignore
 â”£ ğŸ“œmain.py
 â”£ ğŸ“œREADME.md
 â”— ğŸ“œrequirements.txt