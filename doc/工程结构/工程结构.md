æˆ‘å…ˆåœ¨æœ‰ä¸¤ä¸ªpyæ–‡ä»¶éœ€è¦åŒæ—¶è¿è¡Œzebra_crossing_detection.pyå’Œred_light_detection.pyï¼Œåº”è¯¥æ€ä¹ˆåšï¼Ÿ

å·¥ç¨‹ç»“æ„ï¼š
ğŸ“¦zebra_crossing_detection
 â”£ ğŸ“‚doc
 â”ƒ â”£ ğŸ“‚æ–‘é©¬çº¿æµç¨‹
 â”ƒ â”ƒ â”£ ğŸ“œä»£ç æµç¨‹.ipynb
 â”ƒ â”ƒ â”— ğŸ“œæ•´ä½“æµç¨‹.md
 â”ƒ â”£ ğŸ“‚çº¢ç»¿ç¯æµç¨‹
 â”ƒ â”ƒ â”— ğŸ“œæµç¨‹.md
 â”ƒ â”— ğŸ“‚è®ºæ–‡èµ„æ–™
 â”ƒ â”ƒ â”£ ğŸ“‚OpenCV
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œæ–‘é©¬çº¿æ™ºèƒ½åˆ†å‰²åŠè¡Œäººä½ç½®è‡ªåŠ¨åˆ¤åˆ«æ–¹æ³•ç ”ç©¶_æå¹³åŸ.pdf
 â”ƒ â”ƒ â”ƒ â”— ğŸ“œè½¦è½½æ¿€å…‰ç‚¹äº‘æ–‘é©¬çº¿æå–æ–¹æ³•ç ”ç©¶_ç‹è€€.pdf
 â”ƒ â”ƒ â”— ğŸ“‚äººå·¥æ™ºèƒ½
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œåŸºäºæ”¹è¿›SegNetæ¨¡å‹çš„æ–‘é©¬çº¿æ£€æµ‹æ–¹æ³•ç ”ç©¶_ä»˜é˜³é˜³.pdf
 â”ƒ â”ƒ â”ƒ â”— ğŸ“œåŸºäºæ·±åº¦å­¦ä¹ çš„é“è·¯æ–‘é©¬çº¿ä¸è¡Œäººè¿åŠ¨æ£€æµ‹ç®—æ³•ç ”ç©¶ä¸åº”ç”¨_ä»˜é˜³é˜³.pdf
 â”£ ğŸ“‚image
 â”ƒ â”£ ğŸ“œ1.png
 â”ƒ â”£ ğŸ“œ1_gray.png
 â”ƒ â”£ ğŸ“œ2.png
 â”ƒ â”£ ğŸ“œ3.png
 â”ƒ â”£ ğŸ“œfe9ee2fae4d6cc95f3bce01334d1016.jpg
 â”ƒ â”— ğŸ“œRED_LIGHT.png
 â”£ ğŸ“‚Parameter_adjustment_assistant
 â”ƒ â”£ ğŸ“œredlight_debug.py
 â”ƒ â”— ğŸ“œzebra_debug.py
 â”£ ğŸ“‚test
 â”ƒ â”£ ğŸ“œcamera_test.py
 â”ƒ â”£ ğŸ“œcanny_debug.py
 â”ƒ â”£ ğŸ“œGrayscale_threshold_debug.py
 â”ƒ â”— ğŸ“œHSV_debug.py
 â”£ ğŸ“‚traffic_detection
 â”ƒ â”— ğŸ“œred_light_detection.py
 â”£ ğŸ“‚zebra_detection
 â”ƒ â”— ğŸ“œzebra_crossing_detection.py
 â”— ğŸ“œ.gitignore


## ä»£ç ï¼š

### 1 ebra_crossing_detection.pyï¼š

```python
import cv2
import numpy as np

def on_trackbar_change(val):
    pass

def ensure_odd(val):
    return val if val % 2 == 1 else val + 1

def zebra_crossing_detection():
    cap = cv2.VideoCapture(0)  # ä½¿ç”¨æ‘„åƒå¤´
    if not cap.isOpened():
        print("Error: Unable to open camera.")
        return
    
    # åˆ›å»ºçª—å£å’Œæ»‘åŠ¨æ¡
    steps = ['1. Cropped Image', '2. Gray Image', '3. Median Blurred Image', '4. Gaussian Blurred Image', 
             '5. Canny Edges', '6. Morphologically Closed Edges', '7. Mask with Contours', 
             '8. ROI Image', '9. ROI Canny Edges', '10. Detected Lines']
    
    for step in steps:
        cv2.namedWindow(step)

    cv2.createTrackbar('Crop %', '1. Cropped Image', 30, 100, on_trackbar_change)
    cv2.createTrackbar('Median Blur', '3. Median Blurred Image', 15, 20, on_trackbar_change)
    cv2.createTrackbar('Gaussian Blur', '4. Gaussian Blurred Image', 0, 15, on_trackbar_change)
    cv2.createTrackbar('Canny Threshold 1', '5. Canny Edges', 50, 200, on_trackbar_change)
    cv2.createTrackbar('Canny Threshold 2', '5. Canny Edges', 134, 300, on_trackbar_change)
    cv2.createTrackbar('Morph Kernel', '6. Morphologically Closed Edges', 1, 20, on_trackbar_change)
    cv2.createTrackbar('Area Threshold', '6. Morphologically Closed Edges', 3000, 5000, on_trackbar_change)
    cv2.createTrackbar('Hough Threshold', '10. Detected Lines', 16, 200, on_trackbar_change)
    cv2.createTrackbar('Line Threshold', '10. Detected Lines', 10, 50, on_trackbar_change)

    while True:
        ret, frame = cap.read()  # ä»æ‘„åƒå¤´è¯»å–å¸§
        if not ret:
            print("Error: Unable to capture frame.")
            break

        # è·å–æ»‘åŠ¨æ¡çš„å€¼
        crop_percent = cv2.getTrackbarPos('Crop %', '1. Cropped Image') / 100.0
        median_blur_val = ensure_odd(cv2.getTrackbarPos('Median Blur', '3. Median Blurred Image'))
        gaussian_blur_val = ensure_odd(cv2.getTrackbarPos('Gaussian Blur', '4. Gaussian Blurred Image'))
        canny_threshold1 = cv2.getTrackbarPos('Canny Threshold 1', '5. Canny Edges')
        canny_threshold2 = cv2.getTrackbarPos('Canny Threshold 2', '5. Canny Edges')
        morph_kernel_size = cv2.getTrackbarPos('Morph Kernel', '6. Morphologically Closed Edges')
        area_threshold = cv2.getTrackbarPos('Area Threshold', '6. Morphologically Closed Edges')
        hough_threshold = cv2.getTrackbarPos('Hough Threshold', '10. Detected Lines')
        line_threshold = cv2.getTrackbarPos('Line Threshold', '10. Detected Lines')

        # å¤„ç†å›¾åƒ
        height = frame.shape[0]
        cropped_image = frame[int(crop_percent * height):, :]
        cv2.imshow('1. Cropped Image', cropped_image)
        
        gray = cv2.cvtColor(cropped_image, cv2.COLOR_BGR2GRAY)
        cv2.imshow('2. Gray Image', gray)
        
        # åº”ç”¨ä¸­å€¼æ»¤æ³¢
        if median_blur_val > 1:
            blurred = cv2.medianBlur(gray, median_blur_val)
        else:
            blurred = gray
        cv2.imshow('3. Median Blurred Image', blurred)
        
        # åº”ç”¨é«˜æ–¯æ¨¡ç³Š
        if gaussian_blur_val > 1:
            gaussian_blurred = cv2.GaussianBlur(blurred, (gaussian_blur_val, gaussian_blur_val), 0)
        else:
            gaussian_blurred = blurred
        cv2.imshow('4. Gaussian Blurred Image', gaussian_blurred)
        
        edges = cv2.Canny(gaussian_blurred, canny_threshold1, canny_threshold2)
        cv2.imshow('5. Canny Edges', edges)
        
        kernel = np.ones((morph_kernel_size, morph_kernel_size), np.uint8)
        closed_edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)
        cv2.imshow('6. Morphologically Closed Edges', closed_edges)
        
        contours, _ = cv2.findContours(closed_edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        mask = np.zeros_like(closed_edges)
        for contour in contours:
            if cv2.contourArea(contour) > area_threshold:
                cv2.drawContours(mask, [contour], -1, (255), thickness=cv2.FILLED)
        cv2.imshow('7. Mask with Contours', mask)
        
        roi = cv2.bitwise_and(cropped_image, cropped_image, mask=mask)
        cv2.imshow('8. ROI Image', roi)
        
        roi_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        roi_edges = cv2.Canny(roi_gray, canny_threshold1, canny_threshold2)
        cv2.imshow('9. ROI Canny Edges', roi_edges)
        
        lines = cv2.HoughLinesP(roi_edges, 1, np.pi / 180, threshold=hough_threshold, minLineLength=50, maxLineGap=10)
        
        line_image = np.copy(cropped_image)
        if lines is not None:
            for line in lines:
                for x1, y1, x2, y2 in line:
                    cv2.line(line_image, (x1, y1), (x2, y2), (0, 255, 0), 2)
        cv2.imshow('10. Detected Lines', line_image)
        
        detected = lines is not None and len(lines) > line_threshold
        
        if cv2.waitKey(1) & 0xFF == 27:  # æŒ‰ä¸‹ 'Esc' é”®é€€å‡º
            break

    cap.release()
    cv2.destroyAllWindows()
    return detected

# è°ƒç”¨å‡½æ•°è¿›è¡Œæµ‹è¯•
detected = zebra_crossing_detection()
print("Zebra Crossing Detected: ", detected)
```

### 2 red_light_detection.pyï¼š

```python
import cv2
import numpy as np

def on_trackbar_change(val):
    pass

def ensure_odd(val):
    return val if val % 2 == 1 else val + 1

def red_light_detection():
    # æ‰“å¼€æ‘„åƒå¤´
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("Cannot open camera")
        return
    
    # åˆ›å»ºçª—å£å’Œæ»‘åŠ¨æ¡
    steps = [
        '1. Original Image', '2. Smooth Image', '3. Gaussian Blurred Image', 
        '4. HSV Red Mask', '5. Morphological Transform', '6. Contours and Red Light'
    ]
    
    for step in steps:
        cv2.namedWindow(step)

    cv2.createTrackbar('Smooth Kernel', '2. Smooth Image', 20, 30, on_trackbar_change)
    cv2.createTrackbar('Gaussian Blur', '3. Gaussian Blurred Image', 10, 50, on_trackbar_change)
    cv2.createTrackbar('Lower Hue', '4. HSV Red Mask', 0, 180, on_trackbar_change)
    cv2.createTrackbar('Upper Hue', '4. HSV Red Mask', 10, 180, on_trackbar_change)
    cv2.createTrackbar('Lower Saturation', '4. HSV Red Mask', 100, 255, on_trackbar_change)
    cv2.createTrackbar('Upper Saturation', '4. HSV Red Mask', 255, 255, on_trackbar_change)
    cv2.createTrackbar('Lower Value', '4. HSV Red Mask', 100, 255, on_trackbar_change)
    cv2.createTrackbar('Upper Value', '4. HSV Red Mask', 255, 255, on_trackbar_change)
    cv2.createTrackbar('Erode/Dilate Kernel', '5. Morphological Transform', 3, 20, on_trackbar_change)
    cv2.createTrackbar('Min Area', '6. Contours and Red Light', 400, 5000, on_trackbar_change)
    cv2.createTrackbar('Max Area', '6. Contours and Red Light', 3000, 5000, on_trackbar_change)

    while True:
        # ä»æ‘„åƒå¤´æ•è·ä¸€å¸§
        ret, original_image = cap.read()
        if not ret:
            print("Failed to grab frame")
            break
        
        # è·å–æ»‘åŠ¨æ¡çš„å€¼
        smooth_kernel_size = ensure_odd(cv2.getTrackbarPos('Smooth Kernel', '2. Smooth Image'))
        gaussian_blur_val = ensure_odd(cv2.getTrackbarPos('Gaussian Blur', '3. Gaussian Blurred Image'))
        lower_hue = cv2.getTrackbarPos('Lower Hue', '4. HSV Red Mask')
        upper_hue = cv2.getTrackbarPos('Upper Hue', '4. HSV Red Mask')
        lower_saturation = cv2.getTrackbarPos('Lower Saturation', '4. HSV Red Mask')
        upper_saturation = cv2.getTrackbarPos('Upper Saturation', '4. HSV Red Mask')
        lower_value = cv2.getTrackbarPos('Lower Value', '4. HSV Red Mask')
        upper_value = cv2.getTrackbarPos('Upper Value', '4. HSV Red Mask')
        morph_kernel_size = ensure_odd(cv2.getTrackbarPos('Erode/Dilate Kernel', '5. Morphological Transform'))
        min_area = cv2.getTrackbarPos('Min Area', '6. Contours and Red Light')
        max_area = cv2.getTrackbarPos('Max Area', '6. Contours and Red Light')

        # æ˜¾ç¤ºåŸå§‹å›¾åƒ
        cv2.imshow('1. Original Image', original_image)

        # å¹³æ»‘æ»¤æ³¢
        smooth = cv2.medianBlur(original_image, smooth_kernel_size)
        cv2.imshow('2. Smooth Image', smooth)
        
        # é«˜æ–¯æ¨¡ç³Š
        gaussian_blurred = cv2.GaussianBlur(smooth, (gaussian_blur_val, gaussian_blur_val), 0)
        cv2.imshow('3. Gaussian Blurred Image', gaussian_blurred)
        
        # è½¬æ¢åˆ° HSV è‰²å½©ç©ºé—´
        hsv = cv2.cvtColor(gaussian_blurred, cv2.COLOR_BGR2HSV)
        
        # æå–çº¢è‰²åŒºåŸŸ
        lower_red = np.array([lower_hue, lower_saturation, lower_value])
        upper_red = np.array([upper_hue, upper_saturation, upper_value])
        mask = cv2.inRange(hsv, lower_red, upper_red)
        cv2.imshow('4. HSV Red Mask', mask)
        
        # å½¢æ€å­¦æ“ä½œï¼Œä¾µèš€å’Œè†¨èƒ€è®©çº¢ç¯è½®å»“é—­åˆ
        kernel = np.ones((morph_kernel_size, morph_kernel_size), np.uint8)
        morph = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
        cv2.imshow('5. Morphological Transform', morph)
        
        # æŸ¥æ‰¾è½®å»“è¯¥æ–¹æ³•è®¡ç®—å‡ºåŒ…å«è½®å»“çš„æœ€å°å¤–æ¥åœ†ï¼Œç„¶åæ¯”è¾ƒåœ†çš„åŠå¾„å’Œè½®å»“çš„é¢ç§¯ã€‚è¿™æ ·å¯ä»¥æ›´ç²¾ç¡®åœ°åˆ¤æ–­è½®å»“æ˜¯å¦è¿‘ä¼¼ä¸ºåœ†å½¢ã€‚
        contours, _ = cv2.findContours(morph, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        detected = False
        output_image = original_image.copy()
        for contour in contours:
            area = cv2.contourArea(contour)
            if min_area < area < max_area:
                (x, y), radius = cv2.minEnclosingCircle(contour)
                center = (int(x), int(y))
                radius = int(radius)
                circle_area = np.pi * (radius ** 2)
                
                if min_area < circle_area < max_area:
                    cv2.circle(output_image, center, radius, (0, 255, 0), 2)
                    detected = True
        
        cv2.imshow('6. Contours and Red Light', output_image)
        
        if cv2.waitKey(1) & 0xFF == 27:  # æŒ‰ä¸‹ 'Esc' é”®é€€å‡º
            break

    cap.release()
    cv2.destroyAllWindows()
    return detected

# è°ƒç”¨å‡½æ•°è¿›è¡Œæµ‹è¯•
detected = red_light_detection()
print("Red Light Detected: ", detected)

```